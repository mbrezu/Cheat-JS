<h1>Cheat-JS - macros for JavaScript. Kinda.</h1>

<h2>Important Note</h2>

<p>Cheat-JS includes a modified version of <code>parse-js</code>, written by Marijn
Haverbeke. This is necessary because I (Miron Brezuleanu) needed to
modify <code>parse-js</code> a little. The license of <code>parse-js</code> is in the
<code>LICENSE-parse-js.txt</code> file. The modified files from <code>parse-js</code>
included in Cheat-JS are <code>parse.lisp</code>, <code>tokenize.lisp</code> and
<code>util.lisp</code>. The modifications were permitted by the <code>parse-js</code>
license. This is not an official copy of <code>parse-js</code> and is not
supported by Marijn Haverbeke. If the modified parsing code in
Cheat-JS breaks, it's exclusively Miron Brezuleanu's fault, because he
messed up the code.</p>

<h2>About Cheat-JS</h2>

<p>Lisp macros are powerful and easy to implement (not so easy to use...)
because Lisp programs are made of s-expressions.</p>

<p>Lisp-style macros are difficult to add to other languages because most
languages have very non-uniform syntax compared to Lisp. Source
transformations (and most importantly macros) would be easier in, say,
JavaScript, if it were possible to convert the JavaScript code into
s-expressions, transform it, and convert it back into JavaScript code.</p>

<p>Turns out that we can transform JavaScript code into an AST made of
s-expressions using
<a href="http://marijnhaverbeke.nl/parse-js/"><code>parse-js</code></a>. Converting back
into JavaScript code can be done with
<a href="https://github.com/mishoo/cl-uglify-js"><code>cl-uglify-js</code></a> (ironically,
<code>cl-uglify-js:ast-gen-code</code> is a capable pretty printer). All that
remains to be done to have macros (well, defined in another language)
is define transformations to be applied on the output of
<code>parse-js</code>. This is what Cheat-JS does: get the <code>parse-js</code> AST, apply
the transformations, convert back to JavaScript code.</p>

<h2>A couple of simple examples</h2>

<p>Instead of writing:</p>

<pre><code>var Person = function(name, shoeSize) {
    this.name = name;
    this.shoeSize = shoeSize;
};
</code></pre>

<p>Cheat-JS makes it possible to write:</p>

<pre><code>var Person = @defclass(name, shoeSize);
</code></pre>

<p>(Some irregularities in JavaScript syntax make it much harder to
expand something like <code>@defclass(Person, name, shoeSize);</code> into
<code>function Person(name, shoeSize) { this.name = name; this.shoeSize =
shoeSize; };</code>).</p>

<p>This assumes that we have defined a <code>@defclass</code> macro which does the
above expansions.</p>

<p>One of the <code>parse-js</code> modifications necessary for this to work is
allow <code>@</code> as a character in identifiers (the recommended convention
for naming macros is <code>@</code> followed by the macro name). Currently macro
names can't be nested (i.e. <code>some.namespace.@iife</code> is not valid
syntax).</p>

<p>Instead of writing:</p>

<pre><code>var greeter = (function () {
    return {
        'hello': function(name) {
            console.log('hello, '+ name);
        };
    };
}());
</code></pre>

<p>Cheat-JS makes it possible to write:</p>

<pre><code>var greeter = @iife(
    return {
        'hello': function(name) {
            console.log('hello, '+ name);
        }
    };
);
</code></pre>

<p>This assumes that we have defined a <code>@iife</code> macro that wraps its
arguments with <code>(function () { ... }())</code>
(<a href="http://www.benalman.com/news/2010/11/immediately-invoked-function-expression/">meaning of the IIFE acronym</a>).</p>

<p>I also had to modify <code>parse-js</code> to convince it to parse macro
invocations that look like function calls, but have a list of
statements instead of a list of parameters (see the invocation of
<code>@iife</code> above).</p>

<p>Instead of writing:</p>

<pre><code>(function () {
    var test = someTest();
    if (test) {
        console.log("yes!");
    }
})();
</code></pre>

<p>Cheat-JS makes it possible to write:</p>

<pre><code>@when-let(test, someTest();
    console.log("yes!");
);
</code></pre>

<p>This macro is similar to
<a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Data-and-Control-Flow"><code>alexandria:when-let</code></a>. <code>@when-let</code>
has the most complicated interface possible for a Cheat-JS macro: its
argument list has both expressions (<code>test</code>, <code>someTest()</code>) and
statements (the <code>console.log</code> call). When invoking such macros,
separate the expressions and the statements with a semicolon, as in
the example above.</p>

<p>It is of course possible to define the anaphoric version of
<code>@when-let</code>, <code>@awhen</code>.</p>

<p><code>@iife</code>, <code>@defclass</code> (and even a safer version of <code>@defclass</code>),
<code>@when-let</code> and <code>@awhen</code> will be defined in this document (the guide
on how to write Cheat-JS macros is based on these macros).</p>

<h2>Getting started</h2>

<p>You can get Cheat-JS at <code>http://github.com/mbrezu/cheat-js</code>. It's
probably best to <code>git clone</code> it inside the <code>local-projects</code> directory
of your <a href="http://www.quicklisp.org/">Quicklisp</a> install, so you can
load it with <code>(ql:quickload :cheat-js)</code> in your REPL.</p>

<p>Note: I've only tested it with SBCL, so I recommend you use SBCL
too. It should work with other CL implementations, though (all the
code required is standard CL).</p>

<p>Running the tests with:</p>

<pre><code>(cheat-js:run-tests)
</code></pre>

<p>should give you some confidence that things are not obviously broken
(They are most likely broken, but in subtle ways).</p>

<p>The next section should provide you with some pointers on how to
define your Cheat-JS macros.</p>

<h2>Your first Cheat-JS macros</h2>

<p>Before running <code>cheat-js:macroexpand-all</code> on your JavaScript source
code, you need to install your macros.</p>

<p>First reset the list of installed macros,</p>

<pre><code>&gt; (cheat-js:clear-macros)
</code></pre>

<p>To define a macro, you need to know three things:</p>

<ul>
<li>how the macro invocation call looks like (what you want to write in
the JavaScript source code); this is the macro's "API"; it is
JavaScript code (or almost) and the parsed AST;</li>
<li>how the macro expansion looks like; this is the macro's "result";
it is an AST tree;</li>
<li>how to transform the AST of the invocation into the AST of the
expansion; this is the macro's "implementation", written in Common
Lisp.</li>
</ul>

<p>Let's define <code>@defclass</code>.</p>

<h3>Defining <code>@defclass</code></h3>

<p>We need to see how the macro invocation looks like in JavaScript:</p>

<pre><code>var Person = @defclass(name, shoeSize)
</code></pre>

<p>We can tell that the macro is an 'args only' macro (i.e. the
invocation looks like a normal JavaScript function invocation, it does
not contains statements). We can inform Cheat-JS about this:</p>

<pre><code>&gt; (cheat-js:register-args-macro "@defclass")
</code></pre>

<p>We also want to see the AST for the invocation (we use Cheat-JS's
parsing function because the above snippet is not parsable by
<code>parse-js</code> without tweaks; in particular, the parsing won't work as
expected if we don't call <code>register-args-macro</code> as above, so don't
skip that step):</p>

<pre><code>&gt; (cheat-js:parse-js "var Person = @defclass(name, shoeSize);")

(:TOPLEVEL
 ((:VAR
   (("Person" :MACRO-CALL (:NAME "@defclass")
     (:ARGS (:SEQ (:NAME "name") (:NAME "shoeSize"))))))))
</code></pre>

<p>The part that starts with <code>:MACRO-CALL</code> is the interesting part; this
is the AST representation of our macro invocation; this is what we
need to transform into the expansion.</p>

<p>What does the expansion look like? Let's see:</p>

<pre><code>&gt; (cheat-js:parse-js "var Person = function(name, shoeSize)
                      {
                          this.name = name;
                          this.shoeSize = shoeSize;
                      };")

(:TOPLEVEL
 ((:VAR
   (("Person" :FUNCTION NIL ("name" "shoeSize")
     ((:STAT (:ASSIGN T (:DOT (:NAME "this") "name") (:NAME "name")))
      (:STAT
       (:ASSIGN T (:DOT (:NAME "this") "shoeSize") (:NAME "shoeSize")))))))))
</code></pre>

<p>Comparing the two ASTs reveals that we need to transform the
<code>(:MACRO-CALL</code> s-expression into the <code>(:FUNCTION</code> s-expression (don't
worry about the apparently missing <code>(</code> in front of <code>:FUNCTION</code> above,
it's because the list following <code>:VAR</code> is made of conses, not lists).</p>

<p>To make it clearer, we need to write a lisp function to transform this:</p>

<pre><code>(:MACRO-CALL (:NAME "@defclass")
 (:ARGS (:SEQ (:NAME "name") (:NAME "shoeSize"))))
</code></pre>

<p>into this:</p>

<pre><code>(:FUNCTION NIL ("name" "shoeSize")
 ((:STAT (:ASSIGN T (:DOT (:NAME "this") "name") (:NAME "name")))
  (:STAT (:ASSIGN T (:DOT (:NAME "this") "shoeSize") (:NAME "shoeSize")))))
</code></pre>

<p>This part is easy. Just like writing CL macros :-)</p>

<pre><code>&gt; (defun defclass-expander (invocation)
    (let* ((raw-names (cdr (second (third invocation))))
           (names (mapcar #'second raw-names)))
      `(:function nil ,names
                  ,(mapcar (lambda (name)
                             `(:stat
                               (:assign t
                                        (:dot (:name "this")
                                              (:name ,name))
                                        (:name ,name))))
                           names))))
</code></pre>

<p>The parameter <code>invocation</code> is the s-expression starting with
<code>(:MACRO-CALL...</code> above. The value returned by the function should be
the expansion show above (s-expression starting with <code>(:FUNCTION...</code>).</p>

<p>Let's test it:</p>

<pre><code>&gt; (let ((invocation '(:MACRO-CALL
                      (:NAME "@defclass")
                      (:ARGS (:SEQ (:NAME "name") (:NAME "shoeSize"))))))
    (defclass-expander invocation))
(:FUNCTION NIL ("name" "shoeSize")
 ((:STAT (:ASSIGN T (:DOT (:NAME "this") (:NAME "name")) (:NAME "name")))
  (:STAT
   (:ASSIGN T (:DOT (:NAME "this") (:NAME "shoeSize")) (:NAME "shoeSize")))))
</code></pre>

<p>Looks OK. Let's tell Cheat-JS about our function:</p>

<pre><code>&gt; (cheat-js:register-macro-expander "@defclass" #'defclass-expander)
</code></pre>

<p>Now we can ask Cheat-JS to macroexpand our code:</p>

<pre><code>&gt; (cheat-js:macroexpand-all "var Person = @defclass(name, shoeSize);")
"var Person = function(name, shoeSize)
{
    this.name = name;
    this.shoeSize = shoeSize;
};"
</code></pre>

<p><code>cl-uglify-js</code> is a really good pretty printer, isn't it?</p>
