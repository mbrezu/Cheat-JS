<h1>Cheat-JS - macros for JavaScript. Kinda.</h1>

<h2>Important Note</h2>

<p>Cheat-JS includes a modified version of
<a href="http://marijnhaverbeke.nl/parse-js/"><code>parse-js</code></a>, written by Marijn
Haverbeke. This is necessary because I (Miron Brezuleanu) needed to
modify <code>parse-js</code> a little. The license of <code>parse-js</code> is in the
<code>LICENSE-parse-js.txt</code> file. The modified files from <code>parse-js</code>
included in Cheat-JS are <code>parse.lisp</code>, <code>tokenize.lisp</code> and
<code>util.lisp</code>. The modifications were permitted by the <code>parse-js</code>
license. This is not an official copy of <code>parse-js</code> and is not
supported by Marijn Haverbeke. If the modified parsing code in
Cheat-JS breaks, it's exclusively my fault - I messed up the code.</p>

<p>Cheat-JS also uses
<a href="https://github.com/mishoo/cl-uglify-js"><code>cl-uglify-js</code></a> unmodified,
via <a href="http://www.quicklisp.org/">Quicklisp</a>. These two libraries do
most of the work, Cheat-JS is mostly 'glue code'.</p>

<h2>About Cheat-JS</h2>

<p>Lisp macros are powerful and easy to implement because Lisp programs
are made of s-expressions.</p>

<p>Lisp-style macros are difficult to add to other languages because most
languages have very non-uniform syntax compared to Lisp. Source
transformations (and most importantly macros) would be easier in, say,
JavaScript, if it were possible to convert the JavaScript code into
s-expressions, transform it, and convert it back into JavaScript code.</p>

<p>Turns out that we can transform JavaScript code into an AST made of
s-expressions using <code>parse-js</code>. Converting back into JavaScript code
can be done with <code>cl-uglify-js</code> (ironically,
<code>cl-uglify-js:ast-gen-code</code> is a capable pretty printer). All that
remains to be done to have macros (well, defined in another language)
is define transformations to be applied on the output of
<code>parse-js</code>. This is what Cheat-JS does: get the <code>parse-js</code> AST, apply
the transformations, convert back to JavaScript code.</p>

<p>The idea is rather obvious - the main reason Cheat-JS exists is that I
could not find something similar on the net. There are probably many
people who privately do similar things with tools like <code>parse-js</code> and
the pretty-printer part of <code>cl-uglify-js</code> - that, or my Google skills
failed me :)</p>

<h2>BIG WARNING</h2>

<p>I haven't used Cheat-JS on any large projects. I don't have enough
imagination to compensate for this lack of experience, so it may have
a lot of problems I haven't thought about. Right now it's just a proof
of concept.</p>

<h2>Some simple examples</h2>

<p>Instead of writing:</p>

<pre><code>var Person = function(name, shoeSize) {
    this.name = name;
    this.shoeSize = shoeSize;
};
</code></pre>

<p>Cheat-JS makes it possible to write:</p>

<pre><code>var Person = @defclass(name, shoeSize);
</code></pre>

<p>(Some irregularities in JavaScript syntax make it much harder to
expand something like <code>@defclass(Person, name, shoeSize);</code> into
<code>function Person(name, shoeSize) { this.name = name; this.shoeSize =
shoeSize; };</code>).</p>

<p>This assumes that we have defined a <code>@defclass</code> macro which does the
above expansion - we'll define two such macros in this document.</p>

<p>One of the <code>parse-js</code> modifications necessary for this to work is
allow <code>@</code> as a character in identifiers (the recommended convention
for naming macros is <code>@</code> followed by the macro name). Currently macro
names can't be nested (i.e. <code>some.namespace.@iife</code> is not valid
syntax).</p>

<p>Instead of writing:</p>

<pre><code>var greeter = (function () {
    return {
        'hello': function(name) {
            console.log('hello, '+ name);
        };
    };
}());
</code></pre>

<p>Cheat-JS makes it possible to write:</p>

<pre><code>var greeter = @iife(
    return {
        'hello': function(name) {
            console.log('hello, '+ name);
        }
    };
);
</code></pre>

<p>This assumes that we have defined a <code>@iife</code> macro that wraps its
arguments with <code>(function () { ... }())</code>
(<a href="http://www.benalman.com/news/2010/11/immediately-invoked-function-expression/">meaning of the IIFE acronym</a>).</p>

<p>I also had to modify <code>parse-js</code> to convince it to parse macro
invocations that look like function calls, but have a list of
statements instead of a list of parameters (see the invocation of
<code>@iife</code> above).</p>

<p>Instead of writing:</p>

<pre><code>(function () {
    var test = someTest();
    if (test) {
        console.log("Yes!");
        console.log("We passed the test!");
    }
})();
</code></pre>

<p>Cheat-JS makes it possible to write:</p>

<pre><code>@when-let(test, someTest();
    console.log("Yes!");
    console.log("We passed the test!");
);
</code></pre>

<p>This macro is similar to
<a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Data-and-Control-Flow"><code>alexandria:when-let</code></a>. <code>@when-let</code>
has the most complicated interface possible for a Cheat-JS macro: its
argument list has both expressions (<code>test</code>, <code>someTest()</code>) and
statements (the <code>console.log</code> call). When invoking such macros,
separate the expressions and the statements with a semicolon, as in
the example above.</p>

<p>It is of course possible to define the anaphoric version of
<code>@when-let</code>, <code>@awhen</code> (from
<a href="http://paulgraham.com/onlisp.html">OnLisp</a>, page 190).</p>

<p>The guide on how to write Cheat-JS macros is based on defining
<code>@defclass</code> (and even a safer version of <code>@defclass</code>), <code>@iife</code>,
<code>@when-let</code> and <code>@awhen</code>. So all potential misteries introduced by
this section will be cleared by the end of this document.</p>

<h2>Getting started</h2>

<p>You can get Cheat-JS at <code>http://github.com/mbrezu/cheat-js</code>. It's
probably best to <code>git clone</code> it inside the <code>local-projects</code> directory
of your Quicklisp install, so you can load it with <code>(ql:quickload
:cheat-js)</code> in your REPL.</p>

<p>Note: I've only tested it with SBCL, so I recommend you use SBCL
too. It should work with other CL implementations, though (all the
code required is standard CL).</p>

<p>Running the tests with:</p>

<pre><code>(cheat-js:run-tests)
</code></pre>

<p>gives some confidence that things are not obviously broken (they are
most likely broken, but in ways that are subtle enough to fool the
tests).</p>

<p>The next section will provide you with some pointers on how to define
your Cheat-JS macros. If you run into problems, look at the
<code>tests.lisp</code> file for example code - the code there matches the text
in the next section.</p>

<h2>Your first Cheat-JS macros</h2>

<p>Before running <code>cheat-js:explode</code> on your JavaScript source code, you
need to install your macros.</p>

<p>First reset the list of installed macros,</p>

<pre><code>&gt; (cheat-js:clear-macros)
</code></pre>

<p>To define a macro, you need to know three things:</p>

<ul>
<li>how the macro invocation call looks like (what you want to write in
the JavaScript source code); this is the macro's "API"; it is
JavaScript code (or almost) and the parsed AST for that code;</li>
<li>how the macro expansion looks like; this is the macro's "result";
it is an AST tree;</li>
<li>how to transform the AST of the invocation into the AST of the
expansion; this is the macro's "implementation", written in Common
Lisp.</li>
</ul>

<p>Let's define <code>@defclass</code>.</p>

<h3>Defining <code>@defclass</code></h3>

<p>We need to see how the macro invocation looks like in JavaScript:</p>

<pre><code>var Person = @defclass(name, shoeSize)
</code></pre>

<p>We can tell that the macro is an 'args only' macro (i.e. the
invocation looks like a normal JavaScript function invocation, it does
not contains statements). We can inform Cheat-JS about this:</p>

<pre><code>&gt; (cheat-js:register-args-macro "@defclass")
</code></pre>

<p>We also want to see the AST for the invocation (we use Cheat-JS's
parsing function because the above snippet is not parsable by
<code>parse-js</code> without tweaks; in particular, the parsing won't work as
expected if we don't call <code>register-args-macro</code> as above, so don't
skip that step):</p>

<pre><code>&gt; (cheat-js:parse-js "var Person = @defclass(name, shoeSize);")

(:TOPLEVEL
 ((:VAR
   (("Person" :MACRO-CALL (:NAME "@defclass")
     (:ARGS (:SEQ (:NAME "name") (:NAME "shoeSize"))))))))
</code></pre>

<p>The part that starts with <code>:MACRO-CALL</code> is the interesting part; this
is the AST representation of our macro invocation; this is what we
need to transform into the expansion.</p>

<p>What does the expansion look like? Let's see:</p>

<pre><code>&gt; (cheat-js:parse-js "var Person = function(name, shoeSize)
                      {
                          this.name = name;
                          this.shoeSize = shoeSize;
                      };")

(:TOPLEVEL
 ((:VAR
   (("Person" :FUNCTION NIL ("name" "shoeSize")
     ((:STAT (:ASSIGN T (:DOT (:NAME "this") "name") (:NAME "name")))
      (:STAT
       (:ASSIGN T (:DOT (:NAME "this") "shoeSize") (:NAME "shoeSize")))))))))
</code></pre>

<p>Comparing the two ASTs reveals that we need to transform the
<code>(:MACRO-CALL</code> s-expression into the <code>(:FUNCTION</code> s-expression (don't
worry about the apparently missing <code>(</code> in front of <code>:FUNCTION</code> above,
it's because the list following <code>:VAR</code> is made of conses, not lists).</p>

<p>To make it clearer, we need to write a lisp function to transform this:</p>

<pre><code>(:MACRO-CALL (:NAME "@defclass")
 (:ARGS (:SEQ (:NAME "name") (:NAME "shoeSize"))))
</code></pre>

<p>into this:</p>

<pre><code>(:FUNCTION NIL ("name" "shoeSize")
 ((:STAT (:ASSIGN T (:DOT (:NAME "this") "name") (:NAME "name")))
  (:STAT (:ASSIGN T (:DOT (:NAME "this") "shoeSize") (:NAME "shoeSize")))))
</code></pre>

<p>This part is easy. Just like writing CL macros :-)</p>

<pre><code>&gt; (defun defclass-expander (invocation)
    (let* ((raw-names (cdr (second (third invocation))))
           (names (mapcar #'second raw-names)))
      `(:function nil ,names
                  ,(mapcar (lambda (name)
                             `(:stat
                               (:assign t
                                        (:dot (:name "this") ,name)
                                        (:name ,name))))
                           names))))
</code></pre>

<p>The parameter <code>invocation</code> is the s-expression starting with
<code>(:MACRO-CALL...</code> above. The value returned by the function should be
the expansion show above (s-expression starting with <code>(:FUNCTION...</code>).</p>

<p>Let's test it:</p>

<pre><code>&gt; (let ((invocation '(:MACRO-CALL
                      (:NAME "@defclass")
                      (:ARGS (:SEQ (:NAME "name") (:NAME "shoeSize"))))))
    (defclass-expander invocation))
(:FUNCTION NIL ("name" "shoeSize")
 ((:STAT (:ASSIGN T (:DOT (:NAME "this") "name") (:NAME "name")))
  (:STAT
   (:ASSIGN T (:DOT (:NAME "this") "shoeSize") (:NAME "shoeSize")))))
</code></pre>

<p>Looks OK. Let's tell Cheat-JS about our function:</p>

<pre><code>&gt; (cheat-js:register-macro-expander "@defclass" #'defclass-expander)
</code></pre>

<p>Now we can ask Cheat-JS to macroexpand our code:</p>

<pre><code>&gt; (cheat-js:explode "var Person = @defclass(name, shoeSize);")
"var Person = function(name, shoeSize)
{
    this.name = name;
    this.shoeSize = shoeSize;
};"
</code></pre>

<p><code>cl-uglify-js</code> is a really good pretty printer, isn't it?</p>

<p>On to <code>@iife</code>.</p>

<h3>Defining <code>@iife</code></h3>

<p>Again, we'll go through the invocation, expansion and implementation
for the macro.</p>

<p>Let's recall the JavaScript for the invocation from the examples
above:</p>

<pre><code>var greeter = @iife(
    return {
        'hello': function(name) {
            console.log('hello, '+ name);
        }
    };
);
</code></pre>

<p>This is a 'body' macro - its only argument is a list of JavaScript
statements. Let's tell Cheat-JS:</p>

<pre><code>&gt; (cheat-js:register-body-macro "@iife")
</code></pre>

<p>We can now ask the parser for the invocation AST. We'll work with a
simplified invocation, though - the example above will generate a
large AST, and we can just as well manage with a smaller one. It's
better if our invocation has more than one statement, so let's try
this:</p>

<pre><code>&gt; (cheat-js:parse-js "var a = @iife(alert(1);alert(2););")
(:TOPLEVEL
 ((:VAR
   (("a" :MACRO-CALL (:NAME "@iife")
     (:BODY (:STAT (:CALL (:NAME "alert") ((:NUM 1))))
            (:STAT (:CALL (:NAME "alert") ((:NUM 2))))))))))
</code></pre>

<p>The expansion we desire for this invocation:</p>

<pre><code>&gt; (cheat-js:parse-js "var a = (function() { alert(1); alert(2); })();")
(:TOPLEVEL
 ((:VAR
   (("a" :CALL
     (:FUNCTION NIL NIL
      ((:STAT (:CALL (:NAME "alert") ((:NUM 1))))
       (:STAT (:CALL (:NAME "alert") ((:NUM 2))))))
     NIL)))))
</code></pre>

<p>OK. We need to expand:</p>

<pre><code>(:MACRO-CALL (:NAME "@iife")
  (:BODY (:STAT (:CALL (:NAME "alert") ((:NUM 1))))
         (:STAT (:CALL (:NAME "alert") ((:NUM 2))))))
</code></pre>

<p>into:</p>

<pre><code>(:CALL (:FUNCTION NIL NIL
         ((:STAT (:CALL (:NAME "alert") ((:NUM 1))))
          (:STAT (:CALL (:NAME "alert") ((:NUM 2))))))
       NIL)
</code></pre>

<p>The function to do this is:</p>

<pre><code>(defun iife-expander (invocation)
  `(:CALL (:FUNCTION NIL NIL ,(rest (third invocation)))
          NIL))
</code></pre>

<p>A quick test:</p>

<pre><code>&gt; (let ((invocation '(:MACRO-CALL (:NAME "@iife")
                      (:BODY (:STAT (:CALL (:NAME "alert") ((:NUM 1))))))))
       (iife-expander invocation))
(:CALL
 (:FUNCTION NIL NIL
  ((:STAT (:CALL (:NAME "alert") ((:NUM 1))))
   (:STAT (:CALL (:NAME "alert") ((:NUM 2))))))
 NIL)
</code></pre>

<p>Looks OK. Let's install it:</p>

<pre><code>&gt; (cheat-js:register-macro-expander "@iife" #'iife-expander)
</code></pre>

<p>Let's use it:</p>

<pre><code>&gt; (cheat-js:explode "var a = @iife(alert(1);alert(2););")
"var a = function() {
    alert(1);
    alert(2);
}();"
</code></pre>

<p>Oops. Some parens got dropped. This is not really an issue, the
resulting JavaScript is still valid. Let's try another example:</p>

<pre><code>&gt; (cheat-js:explode "@iife(alert(1);alert(2););")
"(function() {
    alert(1);
    alert(2);
})();"
</code></pre>

<p>Good! The parens were required this time, and they are there.</p>

<p>Now that we have <code>@iife</code> we can write a safer <code>@defclass</code> (and also
see an example of combining Cheat-JS macros).</p>

<h3>Defining a safer <code>@defclass</code></h3>

<p>We used the following Javascript 'class definition' for the
<code>@defclass</code> example:</p>

<pre><code>var Person = function(name, shoeSize)
{
    this.name = name;
    this.shoeSize = shoeSize;
};
</code></pre>

<p>This code has a well-known problem. To create a <code>Person</code> object, one
should use a call like <code>new Person('John', 42);</code> (John's shoe size is
the answer to everything but John is rather boring). If we forget the
<code>new</code>, we are in trouble, because <code>this</code> inside the function no longer
refers to a newly created object, but to <code>window</code>, the global
object. John's marvelous shoe size ends up in the global scope.</p>

<p>Isn't there a way around this? Let's try to define <code>Person</code> like this:</p>

<pre><code>var Person = (function () {
    function Person(name, shoeSize) {
        this.name = name;
        this.shoeSize = shoeSize;
    }
    return function (name, shoeSize) {
        return new Person(name, shoeSize);
    };
}());
</code></pre>

<p>Now it doesn't matter if we use <code>new</code> or we leave it out. A new
<code>Person</code> object is always returned. The new definition is a bit
verbose, though. Maybe we can use... a macro?</p>

<p>Let's examine the three pieces of data we need for a new macro. The
invocation in JavaScript:</p>

<pre><code>var Person = @defclass(Person, name, shoeSize);
</code></pre>

<p>This is certainly more like it, conciseness-wise.</p>

<p>Our new <code>@defclass</code>, like the old one, is an 'args only` macro:</p>

<pre><code>&gt; (cheat-js:register-args-macro "@defclass")
</code></pre>

<p>What about the expansion? Do we want the expansion shown above, or is
it possible to expand to something shorter? This is a macro-combining
opportunity, let's not waste it. The expansion is:</p>

<pre><code>var Person = @iife(
    function Person(name, shoeSize) {
        this.name = name;
        this.shoeSize = shoeSize;
    };
    return function (name, shoeSize) {
        return new Person(name, shoeSize);
    };
);
</code></pre>

<p>The AST of the invocation:</p>

<pre><code>&gt; (cheat-js:parse-js "var Person = @defclass(Person, name, shoeSize);")
(:TOPLEVEL
 ((:VAR
   (("Person" :MACRO-CALL (:NAME "@defclass")
     (:ARGS
      (:SEQ (:NAME "Person") (:SEQ (:NAME "name") (:NAME "shoeSize")))))))))
</code></pre>

<p>Let's make sure Cheat-JS knows what kind of macro <code>@iife</code> is (just in
case we restarted the REPL since we last defined <code>@iife</code>):</p>

<pre><code>&gt; (cheat-js:register-body-macro "@iife")
</code></pre>

<p>Now we can ask <code>cheat-js</code> about AST of the expansion:</p>

<pre><code>&gt; (cheat-js:parse-js "var Person = @iife(
                          function Person(name, shoeSize) {
                              this.name = name;
                              this.shoeSize = shoeSize;
                          };
                          return function (name, shoeSize) {
                              return new Person(name, shoeSize);
                          };
                      );")
(:TOPLEVEL
 ((:VAR
   (("Person" :MACRO-CALL (:NAME "@iife")
     (:BODY
      (:DEFUN "Person" ("name" "shoeSize")
       ((:STAT (:ASSIGN T (:DOT (:NAME "this") "name") (:NAME "name")))
        (:STAT
         (:ASSIGN T (:DOT (:NAME "this") "shoeSize") (:NAME "shoeSize")))))
      (:BLOCK NIL)
      (:RETURN
       (:FUNCTION NIL ("name" "shoeSize")
        ((:RETURN
          (:NEW (:NAME "Person") ((:NAME "name") (:NAME "shoeSize")))))))))))))
</code></pre>

<p>So our <code>:MACRO-CALL</code> expands into a new <code>:MACRO-CALL</code>. Cheat-JS should
be able to handle this, like a good little macroexpander.</p>

<p>To make writing the expansion function easier, let's isolate the
source and target ASTs. The invocation:</p>

<pre><code>(:MACRO-CALL (:NAME "@defclass")
           (:ARGS
            (:SEQ (:NAME "Person")
             (:SEQ (:NAME "name")
                   (:NAME "shoeSize")))))
</code></pre>

<p>and our desired expansion:</p>

<pre><code>(:MACRO-CALL (:NAME "@iife")
 (:BODY
  (:DEFUN "Person" ("name" "shoeSize")
   ((:STAT (:ASSIGN T (:DOT (:NAME "this") "name") (:NAME "name")))
    (:STAT (:ASSIGN T (:DOT (:NAME "this") "shoeSize") (:NAME "shoeSize")))))
  (:BLOCK NIL)
  (:RETURN
   (:FUNCTION NIL ("name" "shoeSize")
    ((:RETURN (:NEW (:NAME "Person") ((:NAME "name")
                                      (:NAME "shoeSize")))))))))
</code></pre>

<p>Wow. This time we generate more code. In order to have macros over
ASTs of manageable dimensions, we'd better combine them.</p>

<h3>Defining <code>@when-let</code></h3>

<h3>Defining <code>@awhen</code></h3>

<h2>Closing thoughts</h2>

<p>Still reading? Wow!</p>

<p>One thing is obvious: Cheat-JS makes it possible to write macro-like
transformations on JavaScript code, but it's not nearly as easy as
writing Common Lisp macros. Maybe this isn't a bad thing - we should
be writing macros only when there's no other way to avoid code
duplication.</p>

<p>There are plenty of quirks. There's only so many transformations you
can do (function calls are not as frequent in JavaScript as they are
in Common Lisp, and macro invocations are 'hooked' to function
calls). Maybe <code>parse-js</code> could be tweaked harder to make it possible
to insert macros at other points. For now, the transformations
possible with 'function call' macros are enough for me.</p>

<p>You need to be able to 'pattern match' ASTs and figure out how to
transform macro invocations ASTs into macro expansions ASTs. This is a
basic macro writing skill, but with an indirection (in Common Lisp the
source code is the AST, not so with JavaScript).</p>

<p>You also need to know Common Lisp. In theory, a Cheat-JS based
preprocessor could be distributed and used by people who are only
'consuming' macros produced by someone else (a 'macro
producer'). Hmmm, people will certainly be amused if a 'macro
producer' starts distributing a 40MB executable (this is about the
minimum size for SBCL standalone executables) that just
explodes some constructs in the source code :-)</p>

<p>With a JavaScript parser written in JavaScript it would be possible to
do what Cheat-JS does without Common Lisp (though without backquotes
the generation of macro expansions is probably a pain, and the AST
would have to be uniform - nested arrays, no classes, maybe? - to make
it easier to 'pattern match' and analyze).</p>

<p>Right now, the audience of Cheat-JS is probably the audience of
ParenScript (mostly because you need to be a lisper to fully use
Cheat-JS). I (Miron Brezuleanu) wrote a few thousands of lines of
ParenScript code and found that there is some 'impedance mismatch'
between ParenScript and JavaScript (especially around the '.' operator
in JavaScript and modules in JavaScript). This was most likely my
fault: instead of writing Lisp to be compiled to JavaScript, I was
trying to write JavaScript with s-expressions. I found it harder to
write code in ParenScript than in JavaScript, and the presence of
macros didn't compensate for this extra effort. I tried to find a way
to have macros while writing something closer to JavaScript. Cheat-JS
is what I came up with.</p>

<p>Thanks for taking the time to read about Cheat-JS; I hope you'll find
it useful (or at least amusing - or both)!</p>

<p>Please use the Github
<a href="https://github.com/mbrezu/cheat-js/issues">issues page</a> to report any
bugs or to post feature requests.</p>
